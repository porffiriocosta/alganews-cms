{"ast":null,"code":"import axios from \"axios\";\nimport Service from \"danielbonifacio-sdk/dist/Service\";\nimport AuthService from \"./Authorization.service\";\nconst {\n  REACT_APP_API_BASE_URL\n} = process.env;\nif (REACT_APP_API_BASE_URL) Service.setBaseUrl(REACT_APP_API_BASE_URL);\nService.setRequestInterceptors(async request => {\n  const accessToken = AuthService.getAccessToken(); // injeta o token de acesso na requisição\n\n  if (accessToken) {\n    request.headers[\"Authorization\"] = `Bearer ${accessToken}`;\n  }\n\n  return request;\n});\nService.setResponseInterceptors(response => response, async error => {\n  var _error$response;\n\n  // recupera informações da requisição\n  const originalRequest = error.config; // caso o erro seja de autenticação e ainda não foi feito o retry\n\n  if ((error === null || error === void 0 ? void 0 : (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 401 && !originalRequest._retry) {\n    originalRequest._retry = true; // recupera o code verifier e o refresh token\n\n    const storage = {\n      codeVerifier: AuthService.getCodeVerifier(),\n      refreshToken: AuthService.getRefreshToken()\n    };\n    const {\n      codeVerifier,\n      refreshToken\n    } = storage; // caso algum não exista, não é possível renovar o token\n\n    if (!refreshToken || !codeVerifier) {\n      AuthService.imperativelySendToLogout();\n      return;\n    } // renova o token\n\n\n    const tokens = await AuthService.getNewToken({\n      codeVerifier,\n      refreshToken\n    }); // armazena os tokens para novas requisições\n\n    AuthService.setAccessToken(tokens.access_token);\n    AuthService.setRefreshToken(tokens.refresh_token); // implementa o token na requisição\n\n    originalRequest.headers[\"Authorization\"] = `Bearer ${tokens.access_token}`; // retorna uma nova chamada do axios com essa requisição\n\n    return axios(originalRequest);\n  }\n\n  throw error;\n});","map":{"version":3,"sources":["D:/ReactProjetos/alganews-cms/src/auth/httpConfig.ts"],"names":["axios","Service","AuthService","REACT_APP_API_BASE_URL","process","env","setBaseUrl","setRequestInterceptors","request","accessToken","getAccessToken","headers","setResponseInterceptors","response","error","originalRequest","config","status","_retry","storage","codeVerifier","getCodeVerifier","refreshToken","getRefreshToken","imperativelySendToLogout","tokens","getNewToken","setAccessToken","access_token","setRefreshToken","refresh_token"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAOC,OAAP,MAAoB,kCAApB;AACA,OAAOC,WAAP,MAAwB,yBAAxB;AAEA,MAAM;AAAEC,EAAAA;AAAF,IAA6BC,OAAO,CAACC,GAA3C;AAEA,IAAIF,sBAAJ,EAA4BF,OAAO,CAACK,UAAR,CAAmBH,sBAAnB;AAE5BF,OAAO,CAACM,sBAAR,CAA+B,MAAOC,OAAP,IAAmB;AAChD,QAAMC,WAAW,GAAGP,WAAW,CAACQ,cAAZ,EAApB,CADgD,CAGhD;;AACA,MAAID,WAAJ,EAAiB;AACfD,IAAAA,OAAO,CAACG,OAAR,CAAgB,eAAhB,IAAoC,UAASF,WAAY,EAAzD;AACD;;AAED,SAAOD,OAAP;AACD,CATD;AAWAP,OAAO,CAACW,uBAAR,CACGC,QAAD,IAAcA,QADhB,EAEE,MAAOC,KAAP,IAAiB;AAAA;;AACf;AACA,QAAMC,eAAe,GAAGD,KAAK,CAACE,MAA9B,CAFe,CAIf;;AACA,MAAI,CAAAF,KAAK,SAAL,IAAAA,KAAK,WAAL,+BAAAA,KAAK,CAAED,QAAP,oEAAiBI,MAAjB,MAA4B,GAA5B,IAAmC,CAACF,eAAe,CAACG,MAAxD,EAAgE;AAC9DH,IAAAA,eAAe,CAACG,MAAhB,GAAyB,IAAzB,CAD8D,CAG9D;;AACA,UAAMC,OAAO,GAAG;AACdC,MAAAA,YAAY,EAAElB,WAAW,CAACmB,eAAZ,EADA;AAEdC,MAAAA,YAAY,EAAEpB,WAAW,CAACqB,eAAZ;AAFA,KAAhB;AAKA,UAAM;AAAEH,MAAAA,YAAF;AAAgBE,MAAAA;AAAhB,QAAiCH,OAAvC,CAT8D,CAW9D;;AACA,QAAI,CAACG,YAAD,IAAiB,CAACF,YAAtB,EAAoC;AAClClB,MAAAA,WAAW,CAACsB,wBAAZ;AACA;AACD,KAf6D,CAiB9D;;;AACA,UAAMC,MAAM,GAAG,MAAMvB,WAAW,CAACwB,WAAZ,CAAwB;AAC3CN,MAAAA,YAD2C;AAE3CE,MAAAA;AAF2C,KAAxB,CAArB,CAlB8D,CAuB9D;;AACApB,IAAAA,WAAW,CAACyB,cAAZ,CAA2BF,MAAM,CAACG,YAAlC;AACA1B,IAAAA,WAAW,CAAC2B,eAAZ,CAA4BJ,MAAM,CAACK,aAAnC,EAzB8D,CA2B9D;;AACAf,IAAAA,eAAe,CAACJ,OAAhB,CACE,eADF,IAEK,UAASc,MAAM,CAACG,YAAa,EAFlC,CA5B8D,CAgC9D;;AACA,WAAO5B,KAAK,CAACe,eAAD,CAAZ;AACD;;AAED,QAAMD,KAAN;AACD,CA5CH","sourcesContent":["import axios from \"axios\";\nimport Service from \"danielbonifacio-sdk/dist/Service\";\nimport AuthService from \"./Authorization.service\";\n\nconst { REACT_APP_API_BASE_URL } = process.env;\n\nif (REACT_APP_API_BASE_URL) Service.setBaseUrl(REACT_APP_API_BASE_URL);\n\nService.setRequestInterceptors(async (request) => {\n  const accessToken = AuthService.getAccessToken();\n\n  // injeta o token de acesso na requisição\n  if (accessToken) {\n    request.headers[\"Authorization\"] = `Bearer ${accessToken}`;\n  }\n\n  return request;\n});\n\nService.setResponseInterceptors(\n  (response) => response,\n  async (error) => {\n    // recupera informações da requisição\n    const originalRequest = error.config;\n\n    // caso o erro seja de autenticação e ainda não foi feito o retry\n    if (error?.response?.status === 401 && !originalRequest._retry) {\n      originalRequest._retry = true;\n\n      // recupera o code verifier e o refresh token\n      const storage = {\n        codeVerifier: AuthService.getCodeVerifier(),\n        refreshToken: AuthService.getRefreshToken(),\n      };\n\n      const { codeVerifier, refreshToken } = storage;\n\n      // caso algum não exista, não é possível renovar o token\n      if (!refreshToken || !codeVerifier) {\n        AuthService.imperativelySendToLogout();\n        return;\n      }\n\n      // renova o token\n      const tokens = await AuthService.getNewToken({\n        codeVerifier,\n        refreshToken,\n      });\n\n      // armazena os tokens para novas requisições\n      AuthService.setAccessToken(tokens.access_token);\n      AuthService.setRefreshToken(tokens.refresh_token);\n\n      // implementa o token na requisição\n      originalRequest.headers[\n        \"Authorization\"\n      ] = `Bearer ${tokens.access_token}`;\n\n      // retorna uma nova chamada do axios com essa requisição\n      return axios(originalRequest);\n    }\n\n    throw error;\n  }\n);\n"]},"metadata":{},"sourceType":"module"}