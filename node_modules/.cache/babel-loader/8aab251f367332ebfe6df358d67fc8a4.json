{"ast":null,"code":"import axios from \"axios\";\nimport Service from \"danielbonifacio-sdk/dist/Service\";\nimport AuthService from \"./Authorization.service\";\nconst {\n  REACT_APP_API_BASE_URL\n} = process.env;\nif (REACT_APP_API_BASE_URL) Service.setBaseUrl(REACT_APP_API_BASE_URL);\nService.setRequestInterceptors(async request => {\n  const accessToken = AuthService.getAccessToken(); // injeta o token de acesso na requisição\n\n  if (accessToken) {\n    request.headers[\"Authorization\"] = `Bearer ${accessToken}`;\n  }\n\n  return request;\n}); // for multiple requests\n\nlet isRefreshing = false;\nlet failedQueue = [];\n\nconst processQueue = (error, token = null) => {\n  failedQueue.forEach(prom => {\n    if (error) {\n      prom.reject(error);\n    } else {\n      prom.resolve(token);\n    }\n  });\n  failedQueue = [];\n};\n\nService.setResponseInterceptors(response => response, async error => {\n  var _error$response;\n\n  // recupera informações da requisição\n  const originalRequest = error.config; // caso o erro seja de autenticação e ainda não foi feito o retry\n\n  if ((error === null || error === void 0 ? void 0 : (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 401 && !originalRequest._retry) {\n    if (isRefreshing) {\n      return new Promise(function (resolve, reject) {\n        failedQueue.push({\n          resolve,\n          reject\n        });\n      }).then(token => {\n        originalRequest.headers[\"Authorization\"] = \"Bearer \" + token;\n        return axios(originalRequest);\n      }).catch(err => {\n        return Promise.reject(err);\n      });\n    }\n\n    originalRequest._retry = true;\n    isRefreshing = true; // recupera o code verifier e o refresh token\n\n    const storage = {\n      codeVerifier: AuthService.getCodeVerifier(),\n      refreshToken: AuthService.getRefreshToken()\n    };\n    const {\n      codeVerifier,\n      refreshToken\n    } = storage; // caso algum não exista, não é possível renovar o token\n\n    if (!refreshToken || !codeVerifier) {\n      AuthService.imperativelySendToLogout();\n      return;\n    }\n\n    try {\n      // renova o token\n      const tokens = await AuthService.getNewToken({\n        codeVerifier,\n        refreshToken\n      }); // armazena os tokens para novas requisições\n\n      AuthService.setAccessToken(tokens.access_token);\n      AuthService.setRefreshToken(tokens.refresh_token); // implementa o token na requisição\n\n      originalRequest.headers[\"Authorization\"] = `Bearer ${tokens.access_token}`;\n      processQueue(null, tokens.access_token); // retorna uma nova chamada do axios com essa requisição\n\n      return axios(originalRequest);\n    } catch (err) {\n      processQueue(err, null);\n      throw err;\n    } finally {\n      isRefreshing = false;\n    }\n  }\n\n  throw error;\n});","map":{"version":3,"sources":["D:/ReactProjetos/alganews-cms/src/auth/httpConfig.ts"],"names":["axios","Service","AuthService","REACT_APP_API_BASE_URL","process","env","setBaseUrl","setRequestInterceptors","request","accessToken","getAccessToken","headers","isRefreshing","failedQueue","processQueue","error","token","forEach","prom","reject","resolve","setResponseInterceptors","response","originalRequest","config","status","_retry","Promise","push","then","catch","err","storage","codeVerifier","getCodeVerifier","refreshToken","getRefreshToken","imperativelySendToLogout","tokens","getNewToken","setAccessToken","access_token","setRefreshToken","refresh_token"],"mappings":"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","sourcesContent":["import axios from \"axios\";\nimport Service from \"danielbonifacio-sdk/dist/Service\";\nimport AuthService from \"./Authorization.service\";\n\nconst { REACT_APP_API_BASE_URL } = process.env;\n\nif (REACT_APP_API_BASE_URL) Service.setBaseUrl(REACT_APP_API_BASE_URL);\n\nService.setRequestInterceptors(async (request) => {\n  const accessToken = AuthService.getAccessToken();\n\n  // injeta o token de acesso na requisição\n  if (accessToken) {\n    request.headers[\"Authorization\"] = `Bearer ${accessToken}`;\n  }\n\n  return request;\n});\n\n// for multiple requests\nlet isRefreshing: boolean = false;\nlet failedQueue: any[] = [];\n\nconst processQueue = (error: any, token: string | null = null) => {\n  failedQueue.forEach((prom) => {\n    if (error) {\n      prom.reject(error);\n    } else {\n      prom.resolve(token);\n    }\n  });\n\n  failedQueue = [];\n};\n\nService.setResponseInterceptors(\n  (response) => response,\n  async (error) => {\n    // recupera informações da requisição\n    const originalRequest = error.config;\n\n    // caso o erro seja de autenticação e ainda não foi feito o retry\n    if (error?.response?.status === 401 && !originalRequest._retry) {\n      if (isRefreshing) {\n        return new Promise(function (resolve, reject) {\n          failedQueue.push({ resolve, reject });\n        })\n          .then((token) => {\n            originalRequest.headers[\"Authorization\"] = \"Bearer \" + token;\n            return axios(originalRequest);\n          })\n          .catch((err) => {\n            return Promise.reject(err);\n          });\n      }\n\n      originalRequest._retry = true;\n      isRefreshing = true;\n\n      // recupera o code verifier e o refresh token\n      const storage = {\n        codeVerifier: AuthService.getCodeVerifier(),\n        refreshToken: AuthService.getRefreshToken(),\n      };\n\n      const { codeVerifier, refreshToken } = storage;\n\n      // caso algum não exista, não é possível renovar o token\n      if (!refreshToken || !codeVerifier) {\n        AuthService.imperativelySendToLogout();\n        return;\n      }\n\n      try {\n        // renova o token\n        const tokens = await AuthService.getNewToken({\n          codeVerifier,\n          refreshToken,\n        });\n\n        // armazena os tokens para novas requisições\n        AuthService.setAccessToken(tokens.access_token);\n        AuthService.setRefreshToken(tokens.refresh_token);\n\n        // implementa o token na requisição\n        originalRequest.headers[\n          \"Authorization\"\n        ] = `Bearer ${tokens.access_token}`;\n\n        processQueue(null, tokens.access_token);\n\n        // retorna uma nova chamada do axios com essa requisição\n        return axios(originalRequest);\n      } catch (err) {\n        processQueue(err, null);\n        throw err;\n      } finally {\n        isRefreshing = false;\n      }\n    }\n\n    throw error;\n  }\n);"]},"metadata":{},"sourceType":"module"}